#pragma once

#include <memory>
#include <array>
#include <glm/glm.hpp>

#include "util/DataStore.hpp"
#include "blocks/Block.hpp"
#include "Structure.hpp"

/**
* Describes a subdivision of the terrain.
*/

class Chunk : public DataStore<Block::unique_ptr_t, 3> {
public:
  Chunk(glm::ivec3 chunkPos, int chunkSize);

  /**
  * Sets the block at the given position.
  * The coordinate origin is in chunk space i.e. (0,0,0) is the chunk corner.
  * This will update the mesh and, if possible, neighboring meshes as well.
  */
  void setBlock(glm::ivec3 pos, Block::unique_ptr_t block);

  bool hasAllNeighbors() const;
  bool hasNoNeighbors() const;
  
  /**
  * Compute the chunk.
  */
  void compute() { computed = true; }

  /**
  * If the chunk has been computed at least once.
  */
  bool isComputed() { return computed; } 

  /// Some lookups for efficient code execution ///

  /**
  * Gets the neighbor at a given offset chunk position.
  * off must be between (-1,-1,-1) and (1, 1, 1) and different from (0, 0, 0).
  */
  std::weak_ptr<Chunk> getNeighbor(glm::ivec3 off);

  /**
  * The chunk's neighbors are the 26 chunks adjacent.
  * Order: see neighborOffsets
  */
  std::array<std::weak_ptr<Chunk>, 26> neighbors;
  
  /**
  * Slices generated by this chunk.
  */
  std::vector<std::weak_ptr<Structure::Slice>> slices;

  /**
  * Specifies the offset position of a neighbor relative to the current chunk.
  * The nth neighbor occupies the position chunkPos + neighborOffsets[n]
  */
  static const std::array<glm::ivec3, 26> neighborOffsets;

  /**
  * Gets n such that neighborOffsets[n] = -neighborOffsets[neighborOffsetsInverse[n]]
  */
  static const std::array<int, 26> neighborOffsetsInverse;

  const glm::ivec3 chunkPos; // chunk index, not world position (position is size * chunkPos)

protected:
  void setBlockAccrossChunks(glm::ivec3 pos, Block::unique_ptr_t block);
  Block* getBlockAccrossChunks(glm::ivec3 pos) const;
  
  bool computed;
};
